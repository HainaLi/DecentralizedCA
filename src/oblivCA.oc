#include "oblivCA.oh"
#include <stdio.h>

// Extended Euclid's Algorithm for Multiplicative Inverse
void mult_inverse(obig *out, obig A, obig M) obliv{
  obig t, r, newt, newr, q, zero, tmp, rem;
  ~obliv(en) {
  obig_init(&t, MAXN);
  obig_init(&r, MAXN);
  obig_init(&newt, MAXN);
  obig_init(&newr, MAXN);
  obig_init(&q, MAXN);
  obig_init(&rem, MAXN);
  obig_init(&tmp, MAXN);
  obig_init(&zero, MAXN);

  obig_zero(&t);
  obig_zero(&zero);
  obig_one(&newt);
  obig_copy(&r, M);
  obig_copy(&newr, A);

  obig *qref = &q;
  obig *remref = &rem;
  obig *rref = &r;
  obig *newrref = &newr;
  obig *tref = &t;
  obig *newtref = &newt;
  obig *tmpref = &tmp;

  int maxiter = 100;
  while(maxiter--){
    obliv if(obig_cmp(newr, zero) != 0)
    {
    
    obig_div_mod(qref, remref, r, newr);

    obig_copy(rref, newr);
    obig_copy(newrref, rem);
    obig_copy(tmpref, newt);

    obig_mul_signed(remref, q, newt);
    obig_sub_signed(newtref, t, rem);
    obig_copy(tref, tmp);
    }
  }
  obliv if(obig_cmp(t, zero) < 0)
    obig_add(tref, t, M);

  obig_copy(out, t);
  
  obig_free(&t);
  obig_free(&r);
  obig_free(&newr);
  obig_free(&newt);
  obig_free(&q);
  obig_free(&rem);
  obig_free(&tmp);
  obig_free(&zero);
  }
}

/*
lambda = (3x^2 + a)/2y
resx = lambda^2 - 2x
resy = lambda(x - resx) - y
*/
void pointDouble(obig* resx, obig* resy, obig px, obig py, obig a, obig p) obliv{
  obig zero, lambda, lambda_mod, lambda2, lambda2_mod, x2, x2_mod, num, den, num_mod, den_mod, tmp, tt, final_x, final_y;
  ~obliv(en) {
  obig_init(&lambda, MAXN);
  obig_init(&lambda_mod, MAXN);
  obig_init(&lambda2, MAXN);
  obig_init(&lambda2_mod, MAXN);
  obig_init(&x2, MAXN);
  obig_init(&x2_mod, MAXN);
  obig_init(&num, MAXN);
  obig_init(&den, MAXN);
  obig_init(&num_mod, MAXN);
  obig_init(&den_mod, MAXN);
  obig_init(&tmp, MAXN);
  obig_init(&tt, MAXN);
  obig_init(&zero, MAXN);
  obig_zero(&zero);
  obig_init(&final_x, MAXN);
  obig_init(&final_y, MAXN);
  
  obig_mul(&x2, px, px);
  obig_div_mod(&tmp, &x2_mod, x2, p);

  obig_add(&num, x2_mod, x2_mod);
  obig_add(&num, num, x2_mod);
  obig_add(&num, num, a);
  obig_div_mod(&tmp, &num_mod, num, p);

  obig_add(&den, py, py);
  obig_div_mod(&tmp, &den_mod, den, p);

  mult_inverse(&den_mod, den_mod, p);
  obig_mul(&lambda, num_mod, den_mod);
  obig_div_mod(&tmp, &lambda_mod, lambda, p);

  obig_mul(&lambda2, lambda_mod, lambda_mod);
  obig_div_mod(&tmp, &lambda2_mod, lambda2, p);

  obig_add(&lambda2_mod, lambda2_mod, p);
  obig_sub(&final_x, lambda2_mod, px);
  obig_add(&final_x, final_x, p);
  obig_sub(&final_x, final_x, px);
  obig_div_mod(&tmp, resx, final_x, p);

  obig_add(&px, px, p);
  obig_sub(&tt, px, *resx);
  
  obig_mul(&tt, lambda_mod, tt);
  obig_div_mod(&tmp, &final_y, tt, p);
  obig_add(&final_y, final_y, p);
  obig_sub(&final_y, final_y, py);
  obig_div_mod(&tmp, resy, final_y, p);

  obig_free(&x2);
  obig_free(&x2_mod);
  obig_free(&lambda);
  obig_free(&lambda_mod);
  obig_free(&lambda2);
  obig_free(&lambda2_mod);
  obig_free(&num);
  obig_free(&den);
  obig_free(&num_mod);
  obig_free(&den_mod);
  obig_free(&tmp);
  obig_free(&tt);
  obig_free(&zero);
  obig_free(&final_x);
  obig_free(&final_y);
  }
}

/*
lambda = (yq - yp)/(xq - xp)
resx = lambda^2 - xp - xq
resy = lambda(x - resx) - y
*/
void pointAdd(obig* resx, obig* resy, obig px, obig py, obig qx, obig qy, obig p) obliv{
  obig zero, lambda, lambda_mod, lambda2, lambda2_mod, num, den, num_mod, den_mod, tt, tmp, final_x, final_y;
  ~obliv(en) {
  obig_init(&lambda, MAXN);
  obig_init(&lambda_mod, MAXN);
  obig_init(&lambda2, MAXN);
  obig_init(&lambda2_mod, MAXN);
  obig_init(&num, MAXN);
  obig_init(&den, MAXN);
  obig_init(&num_mod, MAXN);
  obig_init(&den_mod, MAXN);
  obig_init(&tt, MAXN);
  obig_init(&tmp, MAXN);
  obig_init(&zero, MAXN);
  obig_zero(&zero);
  obig_init(&final_x, MAXN);
  obig_init(&final_y, MAXN);
  

  obig_add(&qy, qy, p);
  obig_sub(&num, qy, py);
  obig_div_mod(&tmp, &num_mod, num, p);

  obig_add(&qx, qx, p);
  obig_sub(&den, qx, px);
  obig_div_mod(&tmp, &den_mod, den, p);

  mult_inverse(&den_mod, den_mod, p);
  obig_mul(&lambda, num_mod, den_mod);
  obig_div_mod(&tmp, &lambda_mod, lambda, p);

  obig_mul(&lambda2, lambda_mod, lambda_mod);
  obig_div_mod(&tmp, &lambda2_mod, lambda2, p);
  
  obig_add(&lambda2_mod, lambda2_mod, p);
  obig_sub(&final_x, lambda2_mod, px);
  obig_add(&final_x, final_x, p);
  obig_sub(&final_x, final_x, qx);
  obig_div_mod(&tmp, resx, final_x, p);

  obig_add(&px, px, p);
  obig_sub(&tt, px, *resx);
  
  obig_mul(&tt, lambda_mod, tt);
  obig_div_mod(&tmp, &final_y, tt, p);
  obig_add(&final_y, final_y, p);
  obig_sub(&final_y, final_y, py);
  obig_div_mod(&tmp, resy, final_y, p);

  obig_free(&lambda);
  obig_free(&lambda_mod);
  obig_free(&lambda2);
  obig_free(&lambda2_mod);
  obig_free(&num);
  obig_free(&den);
  obig_free(&num_mod);
  obig_free(&den_mod);
  obig_free(&tt);
  obig_free(&tmp);
  obig_free(&zero);
  obig_free(&final_x);
  obig_free(&final_y);
  }
}

// elliptic curve point multiplication
void curveMult(obig* resx, obig* resy, obig gx, obig gy, obig d, obig a, obig p) obliv{
  obig Nx, Ny, Qx, Qy, tmpx, tmpy;
  ~obliv(en) {
  obig_init(&Nx, MAXN);
  obig_init(&Ny, MAXN);
  obig_init(&Qx, MAXN);
  obig_init(&Qy, MAXN);
  obig_init(&tmpx, MAXN);
  obig_init(&tmpy, MAXN);

  obig_copy(&Nx, gx);
  obig_copy(&Ny, gy);
  obig_zero(&Qx);
  obig_zero(&Qy);

  obig *Qxref = &Qx;
  obig *Qyref = &Qy;
  obig *Nxref = &Nx;
  obig *Nyref = &Ny;
  obig *tmpxref = &tmpx;
  obig *tmpyref = &tmpy;
  
  for(int ii = 0; ii < d.digits; ii++){
    for(int j = 0; j < 8; j++){
      obliv if(d.data[ii] & (1 << j)){
        obig_copy(tmpxref, Qx);
        obig_copy(tmpyref, Qy);
        pointAdd(Qxref, Qyref, tmpx, tmpy, Nx, Ny, p);
      }
      obig_copy(tmpxref, Nx);
      obig_copy(tmpyref, Ny);
      pointDouble(Nxref, Nyref, tmpx, tmpy, a, p);
    }
    fprintf(stderr,"\n%d\n",ii);
  }
  obig_copy(resx, Qx);
  obig_copy(resy, Qy);
  obig_free(&Nx);
  obig_free(&Ny);
  obig_free(&Qx);
  obig_free(&Qy);
  obig_free(&tmpx);
  obig_free(&tmpy);
  }
}

void signCertificate(void* args){
  
  
  protocolIO *io = args;
  obig pk1, pk2, pk, kk1, kk2, k, pubx, puby, Q_x, Q_y, R_x, R_y, zero_o;
  obig p_o, g_x_o, g_y_o, n_o, a_o, e_o;
  obig tmp, r, k_inverse, interim, interim_mod, s;
  obliv char k1[MAXN], k2[MAXN], ppk1[MAXN], ppk2[MAXN];
  obliv char p_c[MAXN], g_x_c[MAXN], g_y_c[MAXN], n_c[MAXN], a_c[MAXN], e_c[E_LENGTH];
  io->private_key = (char *) malloc(MAXN);

  io->s = (char *) malloc(MAXN);
  io->r = (char *) malloc(MAXN);

  obig_init(&pk1, MAXN);
  obig_init(&pk2, MAXN);
  obig_init(&pk, MAXN);
  obig_init(&kk1, MAXN);
  obig_init(&kk2, MAXN);
  obig_init(&k, MAXN);
  obig_init(&p_o, MAXN);
  obig_init(&g_x_o, MAXN);
  obig_init(&g_y_o, MAXN);
  obig_init(&Q_x, MAXN);
  obig_init(&Q_y, MAXN);
  obig_init(&R_x, MAXN);
  obig_init(&R_y, MAXN);
  obig_init(&n_o, MAXN);
  obig_init(&a_o, MAXN);
  obig_init(&tmp, MAXN);
  obig_init(&r, MAXN);
  obig_init(&e_o, E_LENGTH);
  obig_init(&k_inverse, MAXN);
  obig_init(&interim, MAXN);
  obig_init(&interim_mod, MAXN);
  obig_init(&s, MAXN);

 
  feedOblivCharArray(ppk1, io->private_key_share1, MAXN, 1);
  feedOblivCharArray(ppk2, io->private_key_share2, MAXN, 2);
  feedOblivCharArray(k1, io->k1, MAXN, 1);
  feedOblivCharArray(k2, io->k2, MAXN, 2);
  feedOblivCharArray(p_c, io->p, MAXN, 1);
  feedOblivCharArray(g_x_c, io->g_x, MAXN, 1);
  feedOblivCharArray(g_y_c, io->g_y, MAXN, 1);
  feedOblivCharArray(n_c, io->n, MAXN, 1);
  feedOblivCharArray(a_c, io->a, MAXN, 1);
  feedOblivCharArray(e_c, io->e, E_LENGTH, 1);

  obig_import_opointed(&pk1, ppk1, MAXN);
  obig_import_opointed(&pk2, ppk2, MAXN);
  obig_import_opointed(&kk1, k1, MAXN);
  obig_import_opointed(&kk2, k2, MAXN);
  obig_import_opointed(&p_o, p_c, MAXN);
  obig_import_opointed(&g_x_o, g_x_c, MAXN);
  obig_import_opointed(&g_y_o, g_y_c, MAXN);
  obig_import_opointed(&n_o, n_c, MAXN);
  obig_import_opointed(&a_o, a_c, MAXN);
  obig_import_opointed(&e_o, e_c, E_LENGTH);

  //signing operation follows: http://www.secg.org/sec1-v2.pdf page 23 3.2.1, page 44 4.1.3
  
 
  //1. Select an integer d [1, n-1]
  obig_xor(&pk, pk1, pk2);
  obig_xor(&k, kk1, kk2);
  fprintf(stderr,"\nStep 1 complete....\n");
  //2. Compute Q=dG
  curveMult(&Q_x, &Q_y, g_x_o, g_y_o, pk, a_o, p_o);
  fprintf(stderr,"\nPublic key generated....\n");
  curveMult(&R_x, &R_y, g_x_o, g_y_o, k, a_o, p_o);
  fprintf(stderr,"\nStep 2 complete....\n");
  //3: r = Q_x mod n
  
  obliv bool success = obig_div_mod(&tmp, &r, R_x, n_o);
  revealOblivBool(&io->tempBool, success, 0); 
    
  //Check whether r is zero  
  obig_init(&zero_o, MAXN);
  obig_zero(&zero_o); 
  obliv int8_t r_comp_result = obig_cmp(zero_o, r);
 

  //7. s = k^-1 (e + rd) mod n
  mult_inverse(&k_inverse, k, n_o);
  obig_mul(&interim, r, pk);
  obig_add(&interim, e_o, interim);
  obig_div_mod(&tmp, &interim_mod, interim, n_o);
  obig_mul(&interim, k_inverse, interim_mod);
  obig_div_mod(&tmp, &s, interim, n_o);

  //Check whether s is zero
  obliv int8_t s_comp_result = obig_cmp(zero_o, s);

  for(int ii = 0; ii < r.digits; ii++)
    revealOblivChar(&io->r[ii], r.data[ii], 0);

  for(int ii = 0; ii < s.digits; ii++)
    revealOblivChar(&io->s[ii], s.data[ii], 0);

  obig_free(&pk1);
  obig_free(&pk2);
  obig_free(&pk);
  obig_free(&kk1);
  obig_free(&kk2);
  obig_free(&k);
  obig_free(&k_inverse);
  obig_free(&p_o);
  obig_free(&g_x_o);
  obig_free(&g_y_o);
  obig_free(&Q_x);
  obig_free(&Q_y);
  obig_free(&R_x);
  obig_free(&R_y);
  obig_free(&n_o);
  obig_free(&r);
  obig_free(&zero_o);
  obig_free(&s);
  obig_free(&interim);
  obig_free(&interim_mod);
  
}
