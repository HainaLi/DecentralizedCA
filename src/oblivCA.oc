#include "oblivCA.oh"

/*
lambda = (3x^2 + a)/2y
resx = lambda^2 - 2x
resy = lambda(x - resx) - y
*/
void pointDouble(obig* resx, obig* resy, obig px, obig py, obig a, obig n) obliv{
  obig zero, lambda, lambda2, lambda2_mod, x2, x2_mod, num, den, tmp, tt;
  obig_init(&lambda, MAXN);
  obig_init(&lambda2, MAXN);
  obig_init(&lambda2_mod, MAXN);
  obig_init(&x2, MAXN);
  obig_init(&x2_mod, MAXN);
  obig_init(&num, MAXN);
  obig_init(&den, MAXN);
  obig_init(&tmp, MAXN);
  obig_init(&tt, MAXN);
  obig_init(&zero, MAXN);
  obig_zero(&zero);
  
  obig_mul(&x2_mod, px, px);
  obig_div_mod(&tmp, &x2, x2_mod, n);

  obig_add(&num, x2, x2);
  obliv if(obig_gt(num, n))
    obig_sub(&num, num, n);
  obig_add(&num, num, x2);
  obliv if(obig_gt(num, n))
    obig_sub(&num, num, n);

  obig_add(&num, num, a);
  obliv if(obig_gt(num, n))
    obig_sub(&num, num, n);

  obig_add(&den, py, py);
  obliv if(obig_gt(den, n))
    obig_sub(&den, den, n);

  obig_div_mod_signed(&lambda, &tmp, num, den); // replace with mult-inverse

  obig_mul(&lambda2_mod, lambda, lambda);
  obig_div_mod(&tmp, &lambda2, lambda2_mod, n);

  obig_sub_signed(resx, lambda2, px); // handle subtractions in modular arithmetic
  obliv if(obig_lt(*resx, zero))
    obig_add(resx, *resx, n);
  obig_sub_signed(resx, *resx, px); // handle subtractions in modular arithmetic
  obliv if(obig_lt(*resx, zero))
    obig_add(resx, *resx, n);

  obig_sub_signed(resy, px, *resx); // handle subtractions in modular arithmetic
  obliv if(obig_lt(*resy, zero))
    obig_add(resy, *resy, n);
  obig_mul(resy, lambda, *resy); // handle this
  obig_copy(&tt, *resy);
  obig_div_mod(&tmp, resy, tt, n);
  obig_sub_signed(resy, *resy, py); // handle subtractions in modular arithmetic
  obliv if(obig_lt(*resy, zero))
    obig_add(resy, *resy, n);

  obig_free(&x2);
  obig_free(&x2_mod);
  obig_free(&lambda);
  obig_free(&lambda2);
  obig_free(&lambda2_mod);
  obig_free(&num);
  obig_free(&den);
  obig_free(&tmp);
  obig_free(&tt);
  obig_free(&zero);
}


/*
lambda = (yq - yp)/(xq - xp)
resx = lambda^2 - 2x
resy = lambda(x - resx) - y
*/
void pointAdd(obig* resx, obig* resy, obig px, obig py, obig qx, obig qy, obig n) obliv{
  obig zero, lambda, lambda2, lambda2_mod, num, den, tt, tmp;
  obig_init(&lambda, MAXN);
  obig_init(&lambda2, MAXN);
  obig_init(&lambda2_mod, MAXN);
  obig_init(&num, MAXN);
  obig_init(&den, MAXN);
  obig_init(&tt, MAXN);
  obig_init(&tmp, MAXN);
  obig_init(&zero, MAXN);
  obig_zero(&zero);
  
  obig_sub_signed(&num, qy, py); // handle subtractions in modular arithmetic
  obliv if(obig_lt(num, zero))
    obig_add(&num, num, n);
  obig_sub_signed(&den, qx, px); // handle subtractions in modular arithmetic
  obliv if(obig_lt(den, zero))
    obig_add(&den, den, n);
  obig_div_mod_signed(&lambda, &tmp, num, den); // replace with mult-inverse

  obig_mul(&lambda2_mod, lambda, lambda);
  obig_div_mod(&tmp, &lambda2, lambda2_mod, n);
  
  obig_sub_signed(resx, lambda2, px); // handle subtractions in modular arithmetic
  obliv if(obig_lt(*resx, zero))
    obig_add(resx, *resx, n);
  obig_sub_signed(resx, *resx, qx); // handle subtractions in modular arithmetic
  obliv if(obig_lt(*resx, zero))
    obig_add(resx, *resx, n);

  obig_sub_signed(resy, px, *resx); // handle subtractions in modular arithmetic
  obliv if(obig_lt(*resy, zero))
    obig_add(resy, *resy, n);
  obig_mul(resy, lambda, *resy); // handle this
  obig_copy(&tt, *resy);
  obig_div_mod(&tmp, resy, tt, n);
  obliv if(obig_lt(*resy, zero))
    obig_add(resy, *resy, n);
  obig_sub_signed(resy, *resy, py); // handle subtractions in modular arithmetic

  obig_free(&lambda);
  obig_free(&lambda2);
  obig_free(&lambda2_mod);
  obig_free(&num);
  obig_free(&den);
  obig_free(&tt);
  obig_free(&tmp);
  obig_free(&zero);
}

// elliptic curve point multiplication
void curveMult(obig* resx, obig* resy, obig gx, obig gy, obig d, obig a, obig n) obliv{
  obig Nx, Ny, Qx, Qy;
  obig_init(&Nx, MAXN);
  obig_init(&Ny, MAXN);
  obig_init(&Qx, MAXN);
  obig_init(&Qy, MAXN);
  obig_copy(&Nx, gx);
  obig_copy(&Ny, gy);
  obig_zero(&Qx);
  obig_zero(&Qy);

  for(int ii = 0; ii < d.digits; ii++){
    for(int j = 0; j < 8; j++){
      obliv if(d.data[ii] & (1 << j)){
        pointAdd(&Qx, &Qy, Qx, Qy, Nx, Ny, n);
      }
      pointDouble(&Nx, &Ny, Nx, Ny, a, n);
    }
  }
  obig_copy(resx, Qx);
  obig_copy(resy, Qy);
  obig_free(&Nx);
  obig_free(&Ny);
  obig_free(&Qx);
  obig_free(&Qy);
}

void signCertificate(void* args){
  
  
  protocolIO *io = args;
  obig pk1, pk2, pk, kk1, kk2, k, pubx, puby, qx, qy;
  obig p_o, g_x_o, g_y_o, n_o; 
  obliv char k1[MAXN], k2[MAXN], ppk1[MAXN], ppk2[MAXN];
  obliv char p_c[MAXN], g_x_c[MAXN], g_y_c[MAXN], n_c[MAXN];
  io->private_key = (char *) malloc(MAXN);

  io->output = (int8_t *) malloc(MAXN);
  io->output_r = (char *) malloc(MAXN);

  obig_init(&pk1, MAXN);
  obig_init(&pk2, MAXN);
  obig_init(&pk, MAXN);
  obig_init(&kk1, MAXN);
  obig_init(&kk2, MAXN);
  obig_init(&k, MAXN); 
  obig_init(&p_o, MAXN);
  obig_init(&g_x_o, MAXN);
  obig_init(&g_y_o, MAXN);
  obig_init(&n_o, MAXN);

  obig result_q;
  obig result_r;

  obig_init(&result_q, MAXN);
  obig_init(&result_r, MAXN);
  obig_init(&qx, MAXN);
  obig_init(&qy, MAXN);

 
  feedOblivCharArray(ppk1, io->private_key_share1, MAXN, 1);
  feedOblivCharArray(ppk2, io->private_key_share2, MAXN, 2);
  feedOblivCharArray(k1, io->k1, MAXN, 1);
  feedOblivCharArray(k2, io->k2, MAXN, 2);
  feedOblivCharArray(p_c, io->p, MAXN, 0);
  feedOblivCharArray(g_x_c, io->g_x, MAXN, 0);
  feedOblivCharArray(g_y_c, io->g_y, MAXN, 0);
  feedOblivCharArray(n_c, io->n, MAXN, 0);

  obig_import_opointed(&pk1, ppk1, MAXN);
  obig_import_opointed(&pk2, ppk2, MAXN);
  obig_import_opointed(&kk1, k1, MAXN);
  obig_import_opointed(&kk2, k2, MAXN);
  obig_import_opointed(&p_o, p_c, MAXN);
  obig_import_opointed(&g_x_o, g_x_c, MAXN);
  obig_import_opointed(&g_y_o, g_y_c, MAXN);
  obig_import_opointed(&n_o, n_c, MAXN);

  //xor private keys to obtain a master private key
  obig_xor(&pk, pk1, pk2);

  //signing operation follows: http://www.secg.org/sec1-v2.pdf page 23 3.2.1, page 44 4.1.3

  //1. Select an integer d [1, n-1]
  obig_xor(&k, kk1, kk2);
  //2. Compute Q=dG
  curveMult(&qx, &qy, g_x_o, g_y_o, k, n_o);
  //3: r = Q_x mod n
  
  obliv bool success = obig_div_mod(&result_q, &result_r, qx, n_o);
  revealOblivBool(&io->tempBool, success, 0); 
  unsigned char temp;


  for (int ii = result_q.digits -1; ii >= 0; ii--) {
    revealOblivChar(&temp, result_r.data[ii], 0);
    io->output_r <<= 8; 
    io->output_r += temp; 
  }
  
  
  obig zero_o; 
  
  //Check whether result_r is zero
  
  obig_init(&zero_o, MAXN);
  obig_zero(&zero_o); 
  obliv int8_t r_comp_result = obig_cmp(zero_o, result_r);
  
  revealOblivChar(&io->output, r_comp_result, 0); 

  obig_free(&pk1);
  obig_free(&pk2);
  obig_free(&pk);
  obig_free(&kk1);
  obig_free(&kk2);
  obig_free(&k);
  obig_free(&p_o);
  obig_free(&g_x_o);
  obig_free(&g_y_o);
  obig_free(&n_o);
  obig_free(&result_q);
  obig_free(&result_r);
  obig_free(&zero_o); 
  
}
