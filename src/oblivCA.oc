#include "oblivCA.oh"

// Extended Euclid's Algorithm for Multiplicative Inverse : A^-1 mod M
// Refer to : https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
void mult_inverse(obig *out, obig A, obig M) obliv {
  obig t, r, newt, newr, quotient, zero, tmp, remainder, intermediate; // 'r' and 'newr' are used for repetitive division to find GCD, while 't' and 'newt' simultaneously keep track of inverse. Finally, when 'r' has the GCD, 't' has the inverse of 'A'
  obliv bool tsign = false;
  obliv bool newtsign = false;

  ~obliv(_en) {
    obig_init(&t, MAXN + 1);
    obig_init(&r, MAXN + 1);
    obig_init(&newt, MAXN + 1);
    obig_init(&newr, MAXN + 1);
    obig_init(&quotient, MAXN + 1);
    obig_init(&remainder, MAXN + 1);
    obig_init(&tmp, MAXN + 1);
    obig_init(&intermediate, MAXN + 1);
    obig_init(&zero, MAXN + 1);
  }
  
  newt.data[0] = 1;
  obig_copy(&r, M);
  obig_copy(&newr, A);

  obig *quotientref = &quotient;
  obig *remainderref = &remainder;
  obig *rref = &r;
  obig *newrref = &newr;
  obig *tref = &t;
  obig *newtref = &newt;
  obig *tmpref = &tmp;
  obig *intermediateref = &intermediate;

  int maxiter = MAXN * 8; //! why? - gcd takes log(n) iterations in worst case, which is the number of bits of n
  
  while (maxiter--) {
    obliv if (obig_cmp(newr, zero) != 0) {
      obig_div_mod(quotientref, remainderref, r, newr);

      obig_copy(rref, newr);
      obig_copy(newrref, remainder);

      obig_copy(tmpref, newt);
      obliv bool tmpsign = newtsign;

      obig_mul(intermediateref, quotient, newt);

      obliv if (tsign == tmpsign) {
        obliv if (obig_cmp(intermediate, t) > 0) {
          newtsign = !newtsign;
          obig_sub(newtref, intermediate, t);
        }
        
        obliv if (obig_cmp(intermediate, t) <= 0) {
          obig_sub(newtref, t, intermediate);
        }
      }

      obliv if (tsign != tmpsign) {
        newtsign = !newtsign;
        obig_add(newtref, t, intermediate);
      }

      obig_copy(tref, tmp);
      tsign = tmpsign;
    }
  }
  
  obliv if (tsign == true) {
    obig_sub(tref, M, t);
  }

  obig_copy(out, t);

  ~obliv(_en) {
     obig_free(&t);
     obig_free(&r);
     obig_free(&newr);
     obig_free(&newt);
     obig_free(&quotient);
     obig_free(&remainder);
     obig_free(&tmp);
     obig_free(&zero);
     obig_free(&intermediate);
  }
}

/*
lambda = (3x^2 + a)/2y
resx = lambda^2 - 2x
resy = lambda(x - resx) - y
*/
void pointDouble(obig* resx, obig* resy, obig px, obig py, obig a, obig p) obliv {
  obig zero, lambda, lambda_mod, lambda2, lambda2_mod, x2, x2_mod, num, den, tmp, tt, tx, ty, final_x, final_y;

  ~obliv(_en) {
    obig_init(&lambda, 2 * MAXN);
    obig_init(&lambda_mod, MAXN + 1);
    obig_init(&lambda2, 2 * MAXN);
    obig_init(&lambda2_mod, MAXN + 1);
    obig_init(&x2, 2 * MAXN);
    obig_init(&x2_mod, MAXN + 1);
    obig_init(&num, MAXN + 1);
    obig_init(&den, MAXN + 1);
    obig_init(&tmp, MAXN + 1);
    obig_init(&tt, MAXN + 1);
    obig_init(&zero, MAXN + 1);
    obig_init(&final_x, MAXN + 1);
    obig_init(&final_y, MAXN + 1);
    obig_init(&tx, MAXN + 1);
    obig_init(&ty, MAXN + 1);
  }
  
  obig *numref = &num;
  obig *denref = &den;
  obig *final_xref = &final_x;
  obig *final_yref = &final_y;
  obig *txref = &tx;
  obig *tyref = &ty;
  obig *ttref =&tt;

  obig_mul(&x2, px, px);
  obig_div_mod(&tmp, &x2_mod, x2, p);

  obig_add(&num, x2_mod, x2_mod);
  obliv if (obig_cmp(num, p) >= 0) {
    obig_sub(numref, num, p);
  }
  
  obig_add(&num, num, x2_mod);
  
  obliv if (obig_cmp(num, p) >= 0) {
    obig_sub(numref, num, p);
  }
  
  obig_add(&num, num, a);
  
  obliv if (obig_cmp(num, p) >= 0) {
    obig_sub(numref, num, p);
  }

  obig_add(&den, py, py);
  
  obliv if (obig_cmp(den, p) >= 0) {
    obig_sub(denref, den, p);
  }  

  mult_inverse(&den, den, p);
  obig_mul(&lambda, num, den);
  obig_div_mod(&tmp, &lambda_mod, lambda, p);

  obig_mul(&lambda2, lambda_mod, lambda_mod);
  obig_div_mod(&tmp, &lambda2_mod, lambda2, p);

  obliv if (obig_cmp(lambda2_mod, px) >= 0) {
    obig_sub(txref, lambda2_mod, px);
  }
  
  obliv if (obig_cmp(lambda2_mod, px) < 0) {
    obig_sub(txref, px, lambda2_mod);
    obig_sub(txref, p, tx);
  }
  
  obliv if (obig_cmp(tx, px) >= 0) {
    obig_sub(final_xref, tx, px);
  }
  
  obliv if (obig_cmp(tx, px) < 0) {
    obig_sub(final_xref, px, tx);
    obig_sub(final_xref, p, final_x);
  }

  obliv if (obig_cmp(px, final_x) >= 0) {
    obig_sub(ttref, px, final_x);
  }
  
  obliv if (obig_cmp(px, final_x) < 0) {
    obig_sub(ttref, final_x, px);
    obig_sub(ttref, p, tt);
  }
  
  obig_mul(&lambda, lambda_mod, tt);
  obig_div_mod(&tmp, &ty, lambda, p);
  
  obliv if (obig_cmp(ty, py) >= 0) {
    obig_sub(final_yref, ty, py);
  }
  
  obliv if (obig_cmp(ty, py) < 0) {
    obig_sub(final_yref, py, ty);
    obig_sub(final_yref, p, final_y);
  }

  obig_copy(resx, final_x);
  obig_copy(resy, final_y);

  ~obliv(_en) {
    obig_free(&x2);
    obig_free(&x2_mod);
    obig_free(&lambda);
    obig_free(&lambda_mod);
    obig_free(&lambda2);
    obig_free(&lambda2_mod);
    obig_free(&num);
    obig_free(&den);
    obig_free(&tmp);
    obig_free(&tt);
    obig_free(&zero);
    obig_free(&final_x);
    obig_free(&final_y);
    obig_free(&tx);
    obig_free(&ty);
  }
}

/*
lambda = (yq - yp)/(xq - xp)
resx = lambda^2 - xp - xq
resy = lambda(xp - resx) - yp
*/
void pointAdd(obig* resx, obig* resy, obig px, obig py, obig qx, obig qy, obig p) obliv {
  obig zero, lambda, lambda_mod, lambda2, lambda2_mod, num, den, tt, tx, ty, tmp, final_x, final_y;

  ~obliv(_en) {
    obig_init(&lambda, 2 * MAXN);
    obig_init(&lambda_mod, MAXN + 1);
    obig_init(&lambda2, 2 * MAXN);
    obig_init(&lambda2_mod, MAXN + 1);
    obig_init(&num, MAXN + 1);
    obig_init(&den, MAXN + 1);
    obig_init(&tt, MAXN + 1);
    obig_init(&tmp, MAXN + 1);
    obig_init(&zero, MAXN + 1);
    obig_init(&final_x, MAXN + 1);
    obig_init(&final_y, MAXN + 1);
    obig_init(&tx, MAXN + 1);
    obig_init(&ty, MAXN + 1);
  }

  obig *numref = &num;
  obig *denref = &den;
  obig *final_xref = &final_x;
  obig *final_yref = &final_y;
  obig *txref = &tx;
  obig *tyref = &ty;
  obig *ttref =&tt;

  obliv if (obig_cmp(qy, py) >= 0) {
    obig_sub(numref, qy, py);
  }
  
  obliv if (obig_cmp(qy, py) < 0) {
    obig_sub(numref, py, qy);
    obig_sub(numref, p, num);
  }

  obliv if (obig_cmp(qx, px) >= 0) {
    obig_sub(denref, qx, px);
  }
  
  obliv if (obig_cmp(qx, px) < 0) {
    obig_sub(denref, px, qx);
    obig_sub(denref, p, den);
  }

  mult_inverse(&den, den, p);
  obig_mul(&lambda, num, den);
  obig_div_mod(&tmp, &lambda_mod, lambda, p);

  obig_mul(&lambda2, lambda_mod, lambda_mod);
  obig_div_mod(&tmp, &lambda2_mod, lambda2, p);
  
  obliv if (obig_cmp(lambda2_mod, px) >= 0) {
    obig_sub(txref, lambda2_mod, px);
  }
  
  obliv if (obig_cmp(lambda2_mod, px) < 0) {
    obig_sub(txref, px, lambda2_mod);
    obig_sub(txref, p, tx);
  }

  obliv if (obig_cmp(tx, qx) >= 0) {
    obig_sub(final_xref, tx, qx);
  }
  
  obliv if (obig_cmp(tx, qx) < 0) {
    obig_sub(final_xref, qx, tx);
    obig_sub(final_xref, p, final_x);
  }

  obliv if (obig_cmp(px, final_x) >= 0) {
    obig_sub(ttref, px, final_x);
  }
  
  obliv if (obig_cmp(px, final_x) < 0) {
    obig_sub(ttref, final_x, px);
    obig_sub(ttref, p, tt);
  }
  
  obig_mul(&lambda, lambda_mod, tt);
  obig_div_mod(&tmp, &ty, lambda, p);
  
  obliv if (obig_cmp(ty, py) >= 0) {
    obig_sub(final_yref, ty, py);
  }
  
  obliv if (obig_cmp(ty, py) < 0) {
    obig_sub(final_yref, py, ty);
    obig_sub(final_yref, p, final_y);
  }

  obig_copy(resx, final_x);
  obig_copy(resy, final_y);

  ~obliv(_en) {
    obig_free(&lambda);
    obig_free(&lambda_mod);
    obig_free(&lambda2);
    obig_free(&lambda2_mod);
    obig_free(&num);
    obig_free(&den);
    obig_free(&tt);
    obig_free(&tmp);
    obig_free(&zero);
    obig_free(&final_x);
    obig_free(&final_y);
    obig_free(&tx);
    obig_free(&ty);
  }
}


// elliptic curve point multiplication using montgomery ladder: https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
/* ----- No longer used -----
void curveMultMontgomeryLadder(obig* resx, obig* resy, obig gx, obig gy, obig d, obig a, obig p) obliv {
  obig Nx, Ny, Qx, Qy;
  obliv bool initial = true;
  obliv uint8_t t;

  ~obliv(en) {
  obig_init(&Nx, MAXN);
  obig_init(&Ny, MAXN);
  obig_init(&Qx, MAXN);
  obig_init(&Qy, MAXN);
  }
  obig_copy(&Nx, gx);
  obig_copy(&Ny, gy);

  obig *Qxref = &Qx;
  obig *Qyref = &Qy;
  obig *Nxref = &Nx;
  obig *Nyref = &Ny;
  
  for(int ii = d.digits-1; ii >= 0; ii--){
    for(int j = 7; j >= 0; j--){ 
      t = d.data[ii] & (1 << j);
      obliv if(t == 0){
        obliv if(initial == false) {
          pointAdd(Nxref, Nyref, Qx, Qy, Nx, Ny, p);
          pointDouble(Qxref, Qyref, Qx, Qy, a, p);
        }        
      }

      obliv if(t > 0) {
        obliv if(initial == false) {
          pointAdd(Qxref, Qyref, Qx, Qy, Nx, Ny, p);
        }
        obliv if(initial == true){
          initial = false;
          obig_copy(Qxref, Nx);
          obig_copy(Qyref, Ny);          
        }
        pointDouble(Nxref, Nyref, Nx, Ny, a, p);
      }
    }
  }
  obig_copy(resx, Qx);
  obig_copy(resy, Qy);

  ~obliv(en){
  obig_free(&Nx);
  obig_free(&Ny);
  obig_free(&Qx);
  obig_free(&Qy);
  }
}
*/

// elliptic curve point multiplication
void curveMult(obig* resx, obig* resy, obig gx, obig gy, obig d, obig a, obig p) obliv {
  obig Nx, Ny, Qx, Qy;
  obliv bool initial = true;
  obliv uint8_t t;

  ~obliv(_en) {
    obig_init(&Nx, MAXN);
    obig_init(&Ny, MAXN);
    obig_init(&Qx, MAXN);
    obig_init(&Qy, MAXN);
  }
  
  obig_copy(&Nx, gx);
  obig_copy(&Ny, gy);

  obig *Qxref = &Qx;
  obig *Qyref = &Qy;
  obig *Nxref = &Nx;
  obig *Nyref = &Ny;
  
  for (int ii = 0; ii < d.digits; ii++) {
    for (int j = 0; j < 8; j++) {
      t = d.data[ii] & (1 << j);
      obliv if (t > 0) {
        obliv if (initial == false) {
          pointAdd(Qxref, Qyref, Qx, Qy, Nx, Ny, p);
        }
        obliv if (initial == true) {
          initial = false;
          obig_copy(Qxref, Nx);
          obig_copy(Qyref, Ny);
        }
      }
      pointDouble(Nxref, Nyref, Nx, Ny, a, p);
    }
  }
  obig_copy(resx, Qx);
  obig_copy(resy, Qy);

  ~obliv(_en){
    obig_free(&Nx);
    obig_free(&Ny);
    obig_free(&Qx);
    obig_free(&Qy);
  }
}

void generatePublicKey(void* args) {
  protocolIO *io = args;
  obig pk1, pk2, pk, Q_x, Q_y;
  obig p, g_x, g_y, n, a;
  obliv uint8_t pk1_c[MAXN], pk2_c[MAXN];

  obig_init(&pk1, MAXN);
  obig_init(&pk2, MAXN);
  obig_init(&pk, MAXN);
  obig_init(&p, MAXN);
  obig_init(&g_x, MAXN);
  obig_init(&g_y, MAXN);
  obig_init(&Q_x, MAXN);
  obig_init(&Q_y, MAXN);
  obig_init(&n, MAXN);
  obig_init(&a, MAXN);
 
  assert(ocBroadcastInt(io->proto, 1) == ocBroadcastInt(io->proto, 2));
  assert(ocBroadcastInt(io->operation, 1) == ocBroadcastInt(io->operation, 2));
  assert(ocBroadcastInt(io->operation, 1) != 0 && ocBroadcastInt(io->operation, 2) != 0);
  assert(ocBroadcastInt(io->proto, 1) != 0 && ocBroadcastInt(io->proto, 2) != 0);

  feedOblivCharArray(pk1_c, io->private_key_share1, MAXN, 1);
  feedOblivCharArray(pk2_c, io->private_key_share2, MAXN, 2);

  obig_import_opointed_be(&pk1, pk1_c, MAXN);
  obig_import_opointed_be(&pk2, pk2_c, MAXN);
  obig_import_pointed_be(&p, io->p, MAXN);
  obig_import_pointed_be(&g_x, io->g_x, MAXN);
  obig_import_pointed_be(&g_y, io->g_y, MAXN);
  obig_import_pointed_be(&n, io->n, MAXN);
  obig_import_pointed_be(&a, io->a, MAXN);


  // Public Key Generation follows: http://www.secg.org/sec1-v2.pdf page 23 3.2.1

  // 1. Select an integer d <- [1, n-1], here private key 'pk' corresponds to 'd' 
  obig_xor(&pk, pk1, pk2);
  
  // 2. Compute Q = dG
  curveMult(&Q_x, &Q_y, g_x, g_y, pk, a, p);

  // 3. Output Q
  for (int ii = 0; ii < Q_x.digits; ii++) {
    revealOblivChar(&io->Q_x[ii], Q_x.data[ii], 0);
  }
  
  for(int ii = 0; ii < Q_y.digits; ii++) {
    revealOblivChar(&io->Q_y[ii], Q_y.data[ii], 0);
  }

  printGateCount();
  
  obig_free(&pk1);
  obig_free(&pk2);
  obig_free(&pk);
  obig_free(&p);
  obig_free(&g_x);
  obig_free(&g_y);
  obig_free(&Q_x);
  obig_free(&Q_y);
  obig_free(&n);
  obig_free(&a);
}

void signCertificate(void* args) {
  protocolIO *io = args;
  obig pk1, pk2, pk, k1, k2, k, R_x, R_y, zero;
  obig p, g_x, g_y, n, a, e;
  obig tmp, r, k_inverse, interim, interim_mod, s;
  obliv uint8_t k1_c[MAXN], k2_c[MAXN], pk1_c[MAXN], pk2_c[MAXN];
  obliv bool r_comp_result = false, s_comp_result = false;
  uint8_t e1[E_LENGTH], e2[E_LENGTH];

  obig_init(&pk1, MAXN);
  obig_init(&pk2, MAXN);
  obig_init(&pk, MAXN);
  obig_init(&k1, MAXN);
  obig_init(&k2, MAXN);
  obig_init(&k, MAXN);
  obig_init(&p, MAXN);
  obig_init(&g_x, MAXN);
  obig_init(&g_y, MAXN);
  obig_init(&R_x, MAXN);
  obig_init(&R_y, MAXN);
  obig_init(&n, MAXN);
  obig_init(&a, MAXN);
  obig_init(&e, E_LENGTH);
  obig_init(&tmp, MAXN);
  obig_init(&r, MAXN);
  obig_init(&k_inverse, MAXN);
  obig_init(&interim, 2*MAXN + 1);
  obig_init(&interim_mod, MAXN + 1);
  obig_init(&s, MAXN);
  obig_init(&zero, MAXN);

  assert(ocBroadcastInt(io->proto, 1) == ocBroadcastInt(io->proto, 2));
  assert(ocBroadcastInt(io->operation, 1) == ocBroadcastInt(io->operation, 2));
  assert(ocBroadcastInt(io->operation, 1) != 0 && ocBroadcastInt(io->operation, 2) != 0);
  assert(ocBroadcastInt(io->proto, 1) != 0 && ocBroadcastInt(io->proto, 2) != 0);

  feedOblivCharArray(pk1_c, io->private_key_share1, MAXN, 1);
  feedOblivCharArray(pk2_c, io->private_key_share2, MAXN, 2);
  feedOblivCharArray(k1_c, io->k1, MAXN, 1);
  feedOblivCharArray(k2_c, io->k2, MAXN, 2);

  obig_import_opointed_be(&pk1, pk1_c, MAXN);
  obig_import_opointed_be(&pk2, pk2_c, MAXN);
  obig_import_opointed_be(&k1, k1_c, MAXN);
  obig_import_opointed_be(&k2, k2_c, MAXN);
  obig_import_pointed_be(&p, io->p, MAXN);
  obig_import_pointed_be(&g_x, io->g_x, MAXN);
  obig_import_pointed_be(&g_y, io->g_y, MAXN);
  obig_import_pointed_be(&n, io->n, MAXN);
  obig_import_pointed_be(&a, io->a, MAXN);

  // Hash of tbsCert message is being read in plain text from both the parties
  for (int i = 0; i < E_LENGTH; i++) {
    e1[i] = ocBroadcastChar(io->e1[i], 1);
    e2[i] = ocBroadcastChar(io->e2[i], 2);
  }

  // Assertion is performed if the hash of tbsCert message of both the parties is same
  assert(compare(e1, e2, E_LENGTH));
  obig_import_pointed_be(&e, e1, E_LENGTH);

  // Combine private key shares from both the parties
  obig_xor(&pk, pk1, pk2);


  // Signing operation follows: http://www.secg.org/sec1-v2.pdf page 44 4.1.3

  // 1. Select a curve pair (k, R). First we combine shares from both the parties to obtain 'k'
  obig_xor(&k, k1, k2);

  // Next we get the curve point 'R' corresponding to 'k'
  curveMult(&R_x, &R_y, g_x, g_y, k, a, p);
  
  // 2-3. r = R_x mod n
  obig_div_mod(&tmp, &r, R_x, n);
    
  // Check whether r is zero
  obliv if (obig_cmp(r, zero) == 0) {
    r_comp_result = true;
  }

  // 4-5. Steps 4-5 generate hash of tbsCert message 'e', which we already have, so we skip this

  // 6. s = k^-1 (e + rd) mod n
  mult_inverse(&k_inverse, k, n);
  obig_mul(&interim, r, pk);
  obig_add(&interim, e, interim);
  obig_div_mod(&tmp, &interim_mod, interim, n);
  obig_mul(&interim, k_inverse, interim_mod);
  obig_div_mod(&tmp, &s, interim, n);

  // Check whether s is zero
  obliv if (obig_cmp(s, zero) == 0) {
    s_comp_result = true;
  }

  // Reveal all outputs
  revealOblivBool(&io->RisZero, r_comp_result, 0);
  revealOblivBool(&io->SisZero, s_comp_result, 0);

  printGateCount();

  // 7. Output (r, s)
  for (int ii = 0; ii < r.digits; ii++) {
    revealOblivChar(&io->r[ii], r.data[ii], 0);
  }
  
  for(int ii = 0; ii < s.digits; ii++) {
    revealOblivChar(&io->s[ii], s.data[ii], 0);
  }
  
  obig_free(&pk1);
  obig_free(&pk2);
  obig_free(&pk);
  obig_free(&k1);
  obig_free(&k2);
  obig_free(&k);
  obig_free(&k_inverse);
  obig_free(&p);
  obig_free(&g_x);
  obig_free(&g_y);
  obig_free(&R_x);
  obig_free(&R_y);
  obig_free(&n);
  obig_free(&a);
  obig_free(&tmp);
  obig_free(&r);
  obig_free(&zero);
  obig_free(&s);
  obig_free(&e);
  obig_free(&interim);
  obig_free(&interim_mod); 
}
